var documenterSearchIndex = {"docs":
[{"location":"inference/#inference","page":"Inference","title":"Inference","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"We provide more details on the inference functionalities provided by WidebandDoA and ReversibleJump.","category":"page"},{"location":"inference/#RJMCMC-Samplers","page":"Inference","title":"RJMCMC Samplers","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"Currently, ReversibleJump provides two RJMCMC samplers:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"ReversibleJumpMCMC(order_prior, jump_proposal, mcmc_kernel; jump_rate)\nNonReversibleJumpMCMC(jump_proposal, mcmc_kernel; jump_rate)","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"ReversibleJumpMCMC is the birth-death-update reversible jump MCMC sampler proposed by Green [G1995], while NonReversibleJumpMCMC is the non-reversible counterpart described in the paper, and originally proposed by Gagnon and Doucet[GD2020].","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"[G1995]: Green, Peter J. \"Reversible jump Markov chain Monte Carlo computation and Bayesian model determination.\" Biometrika 82.4 (1995): 711-732.","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"[GD2020]: Gagnon, Philippe, and Arnaud Doucet. \"Nonreversible jump algorithms for Bayesian nested model selection.\" Journal of Computational and Graphical Statistics 30.2 (2020): 312-323.","category":"page"},{"location":"inference/#Arguments","page":"Inference","title":"Arguments","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"order_prior: A prior on the model order.\njump_proposal: A jump proposal provided by WidebandDoA.\nmcmc_kernel: An RJMCMC sampler provided by ReversibleJump.","category":"page"},{"location":"inference/#Keyword-Arguments","page":"Inference","title":"Keyword Arguments","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"jump_rate::Real: Upper bound on the probabiliy of proposing a jump move.","category":"page"},{"location":"inference/#Jump-Proposals","page":"Inference","title":"Jump Proposals","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"We only provide a single option for the jump proposals:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"WidebandDoA.UniformNormalLocalProposal","category":"page"},{"location":"inference/#WidebandDoA.UniformNormalLocalProposal-inference","page":"Inference","title":"WidebandDoA.UniformNormalLocalProposal","text":"UniformNormalLocalProposal(mu, sigma)\n\nUniform proposal over the DoAs and a log-normal propsal over the SNR parameters of a source.\n\nArguments\n\nmu: Mean of the log-normal proposal on the SNR parameter.\nsigma: Standard deviation of the log-normal proposal on the SNR parameter.\n\nThis corresponds to the following proposal:\n\nbeginaligned\n    phi_j sim qleft(phiright) = mathsfUniformleft(-fracpi2 fracpi2right) \n    gamma_j sim qleft(gammaright) = textsfLog-Normalleft(textttmu textttsigmaright)\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"inference/","page":"Inference","title":"Inference","text":"This should be wrapped with","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"    IndepJumpProposal(prop)","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"This can then be used as follows:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"jump   = IndepJumpProposal(prop)\nrjmcmc = ReversibleJumpMCMC(order_prior, jump, mcmc)","category":"page"},{"location":"inference/#MCMC-Samplers","page":"Inference","title":"MCMC Samplers","text":"","category":"section"},{"location":"inference/#Slice-Samplers","page":"Inference","title":"Slice Samplers","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"For the update move, we provide the following selection of MCMC samplers:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"Slice\nSliceSteppingOut\nSliceDoublingOut","category":"page"},{"location":"inference/#WidebandDoA.Slice-inference","page":"Inference","title":"WidebandDoA.Slice","text":"Slice(window)\n\nSlice sampler with fixed search interval.\n\nArguments\n\nwindow::AbstractVector: Initial search interval window.\n\n\n\n\n\n","category":"type"},{"location":"inference/#WidebandDoA.SliceSteppingOut-inference","page":"Inference","title":"WidebandDoA.SliceSteppingOut","text":"SliceSteppingOut(max_stepping_out, window)\nSliceSteppingOut(window)\n\nSlice sampler with the stepping-out procedure.\n\nArguments\n\nmax_stepping_out::Int: Maximum number of stepping outs. (default: 32)\nwindow::AbstractVector: Initial search interval window.\n\n\n\n\n\n","category":"type"},{"location":"inference/#WidebandDoA.SliceDoublingOut-inference","page":"Inference","title":"WidebandDoA.SliceDoublingOut","text":"SliceDoublingOut(max_doubling_out, window)\nSliceDoublingOut(window)\n\nSlice sampler with the doubling-out procedure.\n\nArguments\n\nmax_stepping_out::Int: Maximum number of doubling outs. (default: 8)\nwindow::AbstractVector: Initial search interval window.\n\n\n\n\n\n","category":"type"},{"location":"inference/","page":"Inference","title":"Inference","text":"For more information, refer to the original paper by Neal[N2003].","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"[N2003]: Neal, Radford M. \"Slice sampling.\" The annals of statistics 31.3 (2003): 705-767.","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"info: Info\nFor sampling from WidebandIsoIsoModel, the first element of the window is used for the DoA parameter phi, and the last element is used for loglambda. Therefore, use the following: window = [phi_window, loglambda_window].","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"For example, this can be used as followS:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"mcmc   = SliceSteppingOut([2.0, 2.0]),\nrjmcmc = ReversibleJump.NonReversibleJumpMCMC(jump, mcmc; jump_rate=0.9)","category":"page"},{"location":"inference/#Metropolis-Hastings-Samplers","page":"Inference","title":"Metropolis-Hastings Samplers","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"We also provide Metropolis-Hastings samplers:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"RandomWalkMetropolis\nIndependentMetropolis\nMetropolisMixture","category":"page"},{"location":"inference/#WidebandDoA.RandomWalkMetropolis-inference","page":"Inference","title":"WidebandDoA.RandomWalkMetropolis","text":"RandomWalkMetropolis(sigma) <: AbstractMetropolis\n\nIsotropic Gaussian random walk proposal.\n\nArguments\n\nsigma::Real: Standard deviation of the Gaussian proposal.\n\n\n\n\n\n","category":"type"},{"location":"inference/#WidebandDoA.IndependentMetropolis-inference","page":"Inference","title":"WidebandDoA.IndependentMetropolis","text":"IndependentMetropolis(proposal) <: AbstractMetropolis\n\nIndependent Metropolis Hastings sampler. (Also known as the independence sampler.)\n\nArguments\n\nproposal::UnivariateDistribution: Univariate distribution.\n\n\n\n\n\n","category":"type"},{"location":"inference/#WidebandDoA.MetropolisMixture-inference","page":"Inference","title":"WidebandDoA.MetropolisMixture","text":"MetropolisMixture(imh, rwmh; imh_weight) <: AbstractMetropolis\n\nMixture kernel of an IMH kernel and RWMH kernel, as originally used by Andrieu and Doucet[AD1999].\n\n[AD1999]: Andrieu, Christophe, and Arnaud Doucet. \"Joint Bayesian model selection and estimation of noisy sinusoids via reversible jump MCMC.\" IEEE Transactions on Signal Processing 47.10 (1999): 2667-2676.\n\nArguments\n\nimh::IndependentMetropolis: IMH kernel.\nrwmh::RandomWalkMetropolis: RWMH kernel.\nimh_weight::Real: Mixture weight of selecting the IMH kernel. RWMH kernel is proposed with probability 1 - imh_weight (default: 0.2)\n\n\n\n\n\n","category":"type"},{"location":"inference/","page":"Inference","title":"Inference","text":"To use these, however, the following wrapper has to be used:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"WidebandIsoIsoMetropolis","category":"page"},{"location":"inference/#WidebandDoA.WidebandIsoIsoMetropolis-inference","page":"Inference","title":"WidebandDoA.WidebandIsoIsoMetropolis","text":"WidebandIsoIsoMetropolis(phi_kernel, loglambda_kernel)\n\nWrapper for Metropolis-Hastings (MH) kernels applied to WidebandIsoIsoModel.\n\nArguments\n\nphi_kernel::AbstractMetropolis: MH kernel for the direction-of-arrival parameter phi.\nloglambda_kernel::AbstractMetropolis: MH kernel for the SNR parameter loglambda.\n\n\n\n\n\n","category":"type"},{"location":"inference/","page":"Inference","title":"Inference","text":"For example, this can be used as followS:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"mcmc = WidebandIsoIsoMetropolis(\n    MetropolisMixture(\n        IndependentMetropolis(Uniform(-π/2, π/2)),\n        RandomWalkMetropolis(0.5)\n    ),\n    RandomWalkMetropolis(0.5)\n)\nrjmcmc = ReversibleJump.NonReversibleJumpMCMC(jump, mcmc; jump_rate=0.9)","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [WidebandDoA]","category":"page"},{"location":"api/#WidebandDoA.IndependentMetropolis","page":"API","title":"WidebandDoA.IndependentMetropolis","text":"IndependentMetropolis(proposal) <: AbstractMetropolis\n\nIndependent Metropolis Hastings sampler. (Also known as the independence sampler.)\n\nArguments\n\nproposal::UnivariateDistribution: Univariate distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.MetropolisMixture","page":"API","title":"WidebandDoA.MetropolisMixture","text":"MetropolisMixture(imh, rwmh; imh_weight) <: AbstractMetropolis\n\nMixture kernel of an IMH kernel and RWMH kernel, as originally used by Andrieu and Doucet[AD1999].\n\n[AD1999]: Andrieu, Christophe, and Arnaud Doucet. \"Joint Bayesian model selection and estimation of noisy sinusoids via reversible jump MCMC.\" IEEE Transactions on Signal Processing 47.10 (1999): 2667-2676.\n\nArguments\n\nimh::IndependentMetropolis: IMH kernel.\nrwmh::RandomWalkMetropolis: RWMH kernel.\nimh_weight::Real: Mixture weight of selecting the IMH kernel. RWMH kernel is proposed with probability 1 - imh_weight (default: 0.2)\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.RandomWalkMetropolis","page":"API","title":"WidebandDoA.RandomWalkMetropolis","text":"RandomWalkMetropolis(sigma) <: AbstractMetropolis\n\nIsotropic Gaussian random walk proposal.\n\nArguments\n\nsigma::Real: Standard deviation of the Gaussian proposal.\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.Slice","page":"API","title":"WidebandDoA.Slice","text":"Slice(window)\n\nSlice sampler with fixed search interval.\n\nArguments\n\nwindow::AbstractVector: Initial search interval window.\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.SliceDoublingOut","page":"API","title":"WidebandDoA.SliceDoublingOut","text":"SliceDoublingOut(max_doubling_out, window)\nSliceDoublingOut(window)\n\nSlice sampler with the doubling-out procedure.\n\nArguments\n\nmax_stepping_out::Int: Maximum number of doubling outs. (default: 8)\nwindow::AbstractVector: Initial search interval window.\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.SliceSteppingOut","page":"API","title":"WidebandDoA.SliceSteppingOut","text":"SliceSteppingOut(max_stepping_out, window)\nSliceSteppingOut(window)\n\nSlice sampler with the stepping-out procedure.\n\nArguments\n\nmax_stepping_out::Int: Maximum number of stepping outs. (default: 32)\nwindow::AbstractVector: Initial search interval window.\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.UniformNormalLocalProposal","page":"API","title":"WidebandDoA.UniformNormalLocalProposal","text":"UniformNormalLocalProposal(mu, sigma)\n\nUniform proposal over the DoAs and a log-normal propsal over the SNR parameters of a source.\n\nArguments\n\nmu: Mean of the log-normal proposal on the SNR parameter.\nsigma: Standard deviation of the log-normal proposal on the SNR parameter.\n\nThis corresponds to the following proposal:\n\nbeginaligned\n    phi_j sim qleft(phiright) = mathsfUniformleft(-fracpi2 fracpi2right) \n    gamma_j sim qleft(gammaright) = textsfLog-Normalleft(textttmu textttsigmaright)\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.WidebandConditioned","page":"API","title":"WidebandDoA.WidebandConditioned","text":"WidebandConditioned(model, y)\n\nmodel conditioned on y.\n\nArguments\n\nmodel::AbstractWidebandModel: Signal model.\ny::AbstractMatrix: Received data, where the rows are the channels (sersors), while the columns are the signals.\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.WidebandData","page":"API","title":"WidebandDoA.WidebandData","text":"WidebandData(y, y_fft, y_power)\n\nReceived signal with pre-processing.\n\nArguments\n\ny: Received signal, where the rows are the channels (sersors), while the columns are the signals.\ny_fft: Received signal after applying a channel-wise FFT.\ny_power: Power of the received signal.\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.WidebandIsoIsoLikelihood","page":"API","title":"WidebandDoA.WidebandIsoIsoLikelihood","text":"WidebandIsoIsoLikelihood(n_samples, n_fft, delay_filter, Δx, c, fs)\n\nCollapsed likelihood for a isotropic normal source prior and an isotropic normal noise prior.\n\nArguments\n\nn_samples::Int: Number of samples in received signal.\nn_fft::Int: Length of the latent source signal.\ndelay_filter::AbstractDelayFilter: Delay filter.\nΔx::AbstractVector: Inter-sensor delay in seconds.\nc::Real: Propagation speed of the medium in m/s.\nfs::Real: Sampling rate in Hz.\n\nGiven a parameter NamedTuple(phi[j], loglambda[j]), this likelihood computes:\n\nbeginaligned\n    log pleft(y mid phi_1k gamma_1k alpha beta right) \n    = -fracN + beta2 logleft(fracalpha2 + y^dagger (H Lambda H^dagger + mathrmI)^-1 y right)\n       - frac12 det left(H^dagger Lambda H + mathrmIright)  \n    = -fracN + beta2 logleft(fracalpha2\n       + y^dagger y - y^dagger H left( Lambda^-1 + H^dagger H right)^-1 H^dagger y right)\n       - frac12 detleft(Lambdaright) det left(Lambda^-1 + H^dagger H right) \nendaligned\n\nwhere\n\nLambda = mathrmdiagleft(\n    expleft( texttextsfloglambda0 right)\n    ldots\n    expleft( texttextsfloglambdak right)\n right)\n\n(Note that gamma_j in the paper is lambda[j] in the code, which is a bit confusing.)\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.WidebandIsoIsoMetropolis","page":"API","title":"WidebandDoA.WidebandIsoIsoMetropolis","text":"WidebandIsoIsoMetropolis(phi_kernel, loglambda_kernel)\n\nWrapper for Metropolis-Hastings (MH) kernels applied to WidebandIsoIsoModel.\n\nArguments\n\nphi_kernel::AbstractMetropolis: MH kernel for the direction-of-arrival parameter phi.\nloglambda_kernel::AbstractMetropolis: MH kernel for the SNR parameter loglambda.\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.WidebandIsoIsoModel","page":"API","title":"WidebandDoA.WidebandIsoIsoModel","text":"WidebandIsoIsoModel(n_samples, Δx, c, fs, source_prior, α, β, order_prior, n_fft)\n\nModel for wideband signal model with isotropic normal source prior and isotropic normal noise prior.\n\nArguments\n\nn_samples::Int: Number of samples of the received signal.\nΔx::AbstractVector: Relative sensor location [m].\nc::Real: Propagation speed of the medium [m/s].\nfs::Real: Sampling frequency [Hz].\nsource_prior::UnivariateDistribution: Prior on the SNR parameter (gamma_j in the paper) of the sources.\nα::Real: alpha hyperparameter of the inerse-gamma prior on the signal standard deviation (sigma in the paper; default: 0)\nβ::Real beta hyperparameter of the inerse-gamma prior on the signal standard deviation (sigma in the paper; default: 0)\norder_prior::DiscreteDistribution: Prior on the model order (k in the paper; default: NegativeBinomial(1/2 + 0.1, 0.1/(0.1 + 1)))\nn_fft::Int: Length of the source signals. (default: n_samples*2)\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.WidebandIsoIsoParam","page":"API","title":"WidebandDoA.WidebandIsoIsoParam","text":"WidebandIsoIsoParam(phi, loglambda)\n\nLocal parameter of WidebandIsoIsoModel.\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.WidebandIsoSourcePrior","page":"API","title":"WidebandDoA.WidebandIsoSourcePrior","text":"WidebandIsoSourcePrior(n_samples, n_fft, alpha, beta, order_prior, source_prior)\n\nPrior for wideband signal model, where a Gaussian prior with an isotropic covariance structure is assigned on the latent source signals.\n\nArguments\n\nsamples::Int: Number of samples in the received signal.\nn_fft::Int: Length of the latent signal (N^prime in the paper).\nalpha::Real: alpha hyperparameter for the inverse-gamma prior on the signal variance.\nbeta::Real: beta hyperparameter for the inverse-gamma prior on the signal variance.\norder_prior::DiscreteDistribution: Prior on the number of sources. (Prior on k in the paper.)\nsource_prior::UnivariateDistribution: Hyperprior on the SNR hyperparameter of the sources. (Prior on gamma in the paper.)\n\n\n\n\n\n","category":"type"},{"location":"api/#WidebandDoA.WindowedSinc","page":"API","title":"WidebandDoA.WindowedSinc","text":"WindowedSinc(n_fft) <: AbstractDelayFilter\n\nClosed-form fractional delay filter by Pei and Lai[PL2012][PL2014]\n\nArguments\n\nn_fft::Int: Number of taps of the filter.\n\n[PL2012]: S. -C. Pei and Y. -C. Lai, \"Closed Form Variable Fractional Time Delay Using FFT,\" IEEE Signal Processing Letters, 2012.\n\n[PL2014]: S. -C. Pei and Y. -C. Lai, \"Closed form variable fractional delay using FFT with transition band trade-off,\" In Proceedings of the IEEE International Symposium on Circuits and Systems (ISCAS), 2014.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.rand-Tuple{Random.AbstractRNG, WidebandDoA.AbstractWidebandModel}","page":"API","title":"Base.rand","text":"rand(rng, model)\n\nSample from a wideband signal model.\n\nArguments\n\nrng::Random.AbstractRNG\nmodel: Wideband signal model.\n\nReturns\n\nparams: NamedTuple containing the model parameters.\ndata: Simulated received data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.rand-Tuple{Random.AbstractRNG, WidebandIsoIsoLikelihood, AbstractMatrix, AbstractVector}","page":"API","title":"Base.rand","text":"rand(rng, likelihood::WidebandIsoIsoLikelihood, x, phi; prior, sigma)\n\nSample from the collapsed likelihood for the model with isotropic normal prior and isotropic normal noise.\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator.\nlikelihood::WidebandIsoIsoLikelihood: Likelihood.\nx::AbstractMatrix: Latent source signals, where rows are the signals and columns are sources.\nphi::AbstractVector: Direction-of-arrivals. \n\nKeyword Arguments\n\nprior: Prior object used to sample sigma if needed (default: nothing).\nsigma: Signal standard deviation. (Default samples from InverseGamma(prior.alpha, prior.beta))\n\nReturns\n\ny: A simulated received signal, where the rows are the channels (sensors) and the columns are received signals.\n\nThe sampling process is as follows:\n\nbeginaligned\n    epsilon sim mathcalN(0 sigma^2 mathrmI) \n    x         sim mathcalN(0 sigma^2 H Lambda H^top) \n    y         = x + epsilon  \nendaligned\n\nand the noise epsilon,\n\nbeginaligned\n    y         sim mathcalN(0 sigma^2 left( H Lambda H^top + mathrmI right))\nendaligned\n\nSampling from this distribution is as simple as\n\nbeginaligned\n  y = sigma H Lambda^12 z_x + sigma z_epsilon\nendaligned\n\nwhere z_x and z_epsilon are independent standard Gaussian vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.rand-Tuple{Random.AbstractRNG, WidebandIsoSourcePrior}","page":"API","title":"Base.rand","text":"rand(rng, prior::WidebandIsoSourcePrior, )\n\nSample from prior with isotropic source covariance prior.\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator.\nprior::WidebandIsoSourcePrior: Prior.\n\nKeyword Arguments\n\nk: Model order. (Default samples from prior.model_order.)\nsigma: Signal standard deviation. (Default samples from InverseGamma(prior.alpha, prior.beta).)\nphi: DoA of each sources. (Length must match k; default samples from the uniform distribution over the interval -pi2  pi2.)\nlambda: SNR parameter for each source. (Length must match k; default samples from prior.source_prior.)\n\nThe sampling process is:\n\nbeginaligned\n    k sim textttpriormodel_order \n    sigma sim texttextsfInv-Gamma(textttprioralpha texttextttpriorbeta) \n    phi_j mid k sim texttextsfUniformleft(-fracpi2 fracpi2right) \n    lambda_j mid k sim textttpriorsource_prior \n    x_j mid k sigma lambda_j sim mathcalNleft(0 sigma lambda_j mathrmI right)\nendaligned\n\nReturns\n\nparams: Parameter of wideband signal model. (keys: k, phi, lambda, sigma, x)\n\n\n\n\n\n","category":"method"},{"location":"api/#WidebandDoA.array_delay","page":"API","title":"WidebandDoA.array_delay","text":"array_delay(filter, Δn)\n\nReturns the fourier domain fractional delay filters as a matrix H in mathbbR^ N times M times K . The fractional delay filters are the ones in:\n\n\n\n\n\n","category":"function"},{"location":"api/#WidebandDoA.inter_sensor_delay-Tuple{AbstractVector, AbstractVector, Any}","page":"API","title":"WidebandDoA.inter_sensor_delay","text":"inter_sensor_delay(ϕ, Δx, c)\n\nCompute the inter-sensor delay matrix D in mathbbR^M times K in seconds for a linear array, where M = length(isd) is the number of sensors on the array, and K = length(isd) is the number of targets. The matrix is computed as follows:\n\nD_mk = fracDelta xm  sin(phik)c\n\nArguments\n\nϕ::AbstractVector: Vector of DoAs in radian. \nΔx::AbstractVector: Vector of inter-sensor delay of the array.\nc: Propagation speed of the medium.\n\nReturns\n\ndelays: Matrix containing the delays in seconds. Each row correspond to sensor, and each column correspond to the source.\n\n\n\n\n\n","category":"method"},{"location":"api/#WidebandDoA.loglikelihood","page":"API","title":"WidebandDoA.loglikelihood","text":"loglikelihood(likelihood, params)\n\nLog likelihood of likelihood evaluated on params.\n\n\n\n\n\n","category":"function"},{"location":"api/#WidebandDoA.logpriordensity","page":"API","title":"WidebandDoA.logpriordensity","text":"logpriordensity(prior, params)\n\nLog density of prior evaluated on params.\n\n\n\n\n\n","category":"function"},{"location":"api/#WidebandDoA.reconstruct-Tuple{WidebandConditioned, Any}","page":"API","title":"WidebandDoA.reconstruct","text":"reconstruct(cond::WidebandConditioned, params)\n\nConditional posterior of the latent source signals for reconstruction given conditioned model cond and params\n\nArguments\n\ncond::WidebandConditioned: Conditioned model.\nparams: Additional parameters we need to condition on.\n\nReturns\n\ncond_post: Conditional posterior for the latent source signals.\n\n\n\n\n\n","category":"method"},{"location":"api/#WidebandDoA.relabel-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{<:AbstractVector{T}}, Int64}} where T<:Real","page":"API","title":"WidebandDoA.relabel","text":"relabel(rng, samples, n_mixture; n_iter, n_imh_iter, show_progress)\n\nRelabel the RJMCMC samples samples into n_mixture Gaussian mixtures according to the stochastic expectation maximization (SEM) procedure of Roodaki et al. 2014[RBF2014]. \n\nArguments\n\nrng::Random.AbstractRNG\nsamples::AbstractVector{<:AbstractVector{<:Real}}: Samples subject to relabeling.\nn_mixture::Int: Number of component in the Gaussian mixture. Roodaki et al. recommend setting this as the 80% or 90% percentile of model order posterior.\n\nKeyword Arguments\n\nn_iter::Int: Number of SEM iterations (default: 16).\nn_mh_iter::Int: Number of Metropolis-Hastings steps for sampling an a label assignment (default: 32).\nshow_progress::Bool: Whether to enable progresss line (default: true).\n\nReturns\n\nmixture::Distributions.MixtureModel: The Gaussian mixture model fit over samples.\nlabels::Vector{Vector{Int}}: Labels assigned to each element of each RJCMCM sample.\n\nThe length of each RJCMCMC sample in samples is the model order of that specific sample. Each element of an RJCMCM sample should be the variables that determine which label this element should be associated with.\n\n[RBF2014]: Roodaki, Alireza, Julien Bect, and Gilles Fleury. \"Relabeling and summarizing posterior distributions in signal decomposition problems when the number of components is unknown.\" IEEE Transactions on Signal Processing (2014).\n\n\n\n\n\n","category":"method"},{"location":"general/#General-Usage","page":"General Usage","title":"General Usage","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"We provide detailed documentation of WidebandDoA and ReversibleJump here. A comprehensive example usage of these functionalities can be found in the demo","category":"page"},{"location":"general/#Sampling","page":"General Usage","title":"Sampling","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"This package uses ReversibleJump for drawing samples. To draw samples, the user needs to call the following function","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"ReversibleJump.sample([rng,] sampler, model, N, initial_order; initial_params, show_progress)","category":"page"},{"location":"general/#Arguments","page":"General Usage","title":"Arguments","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"sampler: An RJMCMC sampler provided by ReversibleJump.\nmodel: A model provided by WidebandDoA conditioned on data.\nN::Int: The number of samples.\ninitial_order::Int: The model order of initial_params.","category":"page"},{"location":"general/#Keyword-Arguments","page":"General Usage","title":"Keyword Arguments","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"show_progress::Bool: Whether to enable ProgresMeter\ninitial_params: The initial state of the Markov chain. The order of this parameter must match initial_order for correct results.","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"For more details about the available options for sampler, refer to here.","category":"page"},{"location":"general/#Bayesian-Model","page":"General Usage","title":"Bayesian Model","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"The Bayesian model described in the paper can be constructed through the following constructor:","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"WidebandIsoIsoModel","category":"page"},{"location":"general/#WidebandDoA.WidebandIsoIsoModel-general","page":"General Usage","title":"WidebandDoA.WidebandIsoIsoModel","text":"WidebandIsoIsoModel(n_samples, Δx, c, fs, source_prior, α, β, order_prior, n_fft)\n\nModel for wideband signal model with isotropic normal source prior and isotropic normal noise prior.\n\nArguments\n\nn_samples::Int: Number of samples of the received signal.\nΔx::AbstractVector: Relative sensor location [m].\nc::Real: Propagation speed of the medium [m/s].\nfs::Real: Sampling frequency [Hz].\nsource_prior::UnivariateDistribution: Prior on the SNR parameter (gamma_j in the paper) of the sources.\nα::Real: alpha hyperparameter of the inerse-gamma prior on the signal standard deviation (sigma in the paper; default: 0)\nβ::Real beta hyperparameter of the inerse-gamma prior on the signal standard deviation (sigma in the paper; default: 0)\norder_prior::DiscreteDistribution: Prior on the model order (k in the paper; default: NegativeBinomial(1/2 + 0.1, 0.1/(0.1 + 1)))\nn_fft::Int: Length of the source signals. (default: n_samples*2)\n\n\n\n\n\n","category":"type"},{"location":"general/","page":"General Usage","title":"General Usage","text":"IsoIso in the name indicates that we are using an isotrpoic normal prior on both the source signals and the noise.","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"This model can be conditioned on data by invoking the following constructor:","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"WidebandDoA.WidebandConditioned","category":"page"},{"location":"general/#WidebandDoA.WidebandConditioned-general","page":"General Usage","title":"WidebandDoA.WidebandConditioned","text":"WidebandConditioned(model, y)\n\nmodel conditioned on y.\n\nArguments\n\nmodel::AbstractWidebandModel: Signal model.\ny::AbstractMatrix: Received data, where the rows are the channels (sersors), while the columns are the signals.\n\n\n\n\n\n","category":"type"},{"location":"general/","page":"General Usage","title":"General Usage","text":"The overall process is as follows. Given a received signal y:","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"model = WidebandDoA.WidebandIsoIsoModel(\n    N, Δx, c, fs, source_prior, alpha, beta; order_prior\n)\ncond  = WidebandConditioned(model, y)","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"This can then be used with ReversibleJump.sample.","category":"page"},{"location":"general/#Simulating-Data","page":"General Usage","title":"Simulating Data","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"Given a model, prior and likelihood simulations can be done through the following specialization of Base.rand:","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"Base.rand","category":"page"},{"location":"general/#Base.rand-general","page":"General Usage","title":"Base.rand","text":"rand(rng, model)\n\nSample from a wideband signal model.\n\nArguments\n\nrng::Random.AbstractRNG\nmodel: Wideband signal model.\n\nReturns\n\nparams: NamedTuple containing the model parameters.\ndata: Simulated received data.\n\n\n\n\n\nrand(rng, prior::WidebandIsoSourcePrior, )\n\nSample from prior with isotropic source covariance prior.\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator.\nprior::WidebandIsoSourcePrior: Prior.\n\nKeyword Arguments\n\nk: Model order. (Default samples from prior.model_order.)\nsigma: Signal standard deviation. (Default samples from InverseGamma(prior.alpha, prior.beta).)\nphi: DoA of each sources. (Length must match k; default samples from the uniform distribution over the interval -pi2  pi2.)\nlambda: SNR parameter for each source. (Length must match k; default samples from prior.source_prior.)\n\nThe sampling process is:\n\nbeginaligned\n    k sim textttpriormodel_order \n    sigma sim texttextsfInv-Gamma(textttprioralpha texttextttpriorbeta) \n    phi_j mid k sim texttextsfUniformleft(-fracpi2 fracpi2right) \n    lambda_j mid k sim textttpriorsource_prior \n    x_j mid k sigma lambda_j sim mathcalNleft(0 sigma lambda_j mathrmI right)\nendaligned\n\nReturns\n\nparams: Parameter of wideband signal model. (keys: k, phi, lambda, sigma, x)\n\n\n\n\n\nrand(rng, likelihood::WidebandIsoIsoLikelihood, x, phi; prior, sigma)\n\nSample from the collapsed likelihood for the model with isotropic normal prior and isotropic normal noise.\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator.\nlikelihood::WidebandIsoIsoLikelihood: Likelihood.\nx::AbstractMatrix: Latent source signals, where rows are the signals and columns are sources.\nphi::AbstractVector: Direction-of-arrivals. \n\nKeyword Arguments\n\nprior: Prior object used to sample sigma if needed (default: nothing).\nsigma: Signal standard deviation. (Default samples from InverseGamma(prior.alpha, prior.beta))\n\nReturns\n\ny: A simulated received signal, where the rows are the channels (sensors) and the columns are received signals.\n\nThe sampling process is as follows:\n\nbeginaligned\n    epsilon sim mathcalN(0 sigma^2 mathrmI) \n    x         sim mathcalN(0 sigma^2 H Lambda H^top) \n    y         = x + epsilon  \nendaligned\n\nand the noise epsilon,\n\nbeginaligned\n    y         sim mathcalN(0 sigma^2 left( H Lambda H^top + mathrmI right))\nendaligned\n\nSampling from this distribution is as simple as\n\nbeginaligned\n  y = sigma H Lambda^12 z_x + sigma z_epsilon\nendaligned\n\nwhere z_x and z_epsilon are independent standard Gaussian vectors.\n\n\n\n\n\n","category":"function"},{"location":"general/#Reconstruction","page":"General Usage","title":"Reconstruction","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"Given a conditioned model, reconstruction of the latent signals conditional on a set of parameters can be done through the following function:","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"WidebandDoA.reconstruct","category":"page"},{"location":"general/#WidebandDoA.reconstruct-general","page":"General Usage","title":"WidebandDoA.reconstruct","text":"reconstruct(cond::WidebandConditioned, params)\n\nConditional posterior of the latent source signals for reconstruction given conditioned model cond and params\n\nArguments\n\ncond::WidebandConditioned: Conditioned model.\nparams: Additional parameters we need to condition on.\n\nReturns\n\ncond_post: Conditional posterior for the latent source signals.\n\n\n\n\n\n","category":"function"},{"location":"general/#Relabling","page":"General Usage","title":"Relabling","text":"","category":"section"},{"location":"general/","page":"General Usage","title":"General Usage","text":"As explained in the paper, to analyze the individual sources, the RJMCMC samplers need to be relabeled.  The labels and the Gaussian mixture approximation on the DoAs can be generated through the following function:","category":"page"},{"location":"general/","page":"General Usage","title":"General Usage","text":"WidebandDoA.relabel","category":"page"},{"location":"general/#WidebandDoA.relabel-general","page":"General Usage","title":"WidebandDoA.relabel","text":"relabel(rng, samples, n_mixture; n_iter, n_imh_iter, show_progress)\n\nRelabel the RJMCMC samples samples into n_mixture Gaussian mixtures according to the stochastic expectation maximization (SEM) procedure of Roodaki et al. 2014[RBF2014]. \n\nArguments\n\nrng::Random.AbstractRNG\nsamples::AbstractVector{<:AbstractVector{<:Real}}: Samples subject to relabeling.\nn_mixture::Int: Number of component in the Gaussian mixture. Roodaki et al. recommend setting this as the 80% or 90% percentile of model order posterior.\n\nKeyword Arguments\n\nn_iter::Int: Number of SEM iterations (default: 16).\nn_mh_iter::Int: Number of Metropolis-Hastings steps for sampling an a label assignment (default: 32).\nshow_progress::Bool: Whether to enable progresss line (default: true).\n\nReturns\n\nmixture::Distributions.MixtureModel: The Gaussian mixture model fit over samples.\nlabels::Vector{Vector{Int}}: Labels assigned to each element of each RJCMCM sample.\n\nThe length of each RJCMCMC sample in samples is the model order of that specific sample. Each element of an RJCMCM sample should be the variables that determine which label this element should be associated with.\n\n[RBF2014]: Roodaki, Alireza, Julien Bect, and Gilles Fleury. \"Relabeling and summarizing posterior distributions in signal decomposition problems when the number of components is unknown.\" IEEE Transactions on Signal Processing (2014).\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = WidebandDoA","category":"page"},{"location":"#WidebandDoA","page":"Home","title":"WidebandDoA","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation and demonstration for WidebandDoA.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed documentation of the functionalities of WidebandDoA:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"general.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Detailed documentation on the inference-specific functionalities of WidebandDoA:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"inference.md\"]\nDepth = 2","category":"page"},{"location":"#Demo","page":"Home","title":"Demo","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A general demonstration of the functionalities of WidebandDoA:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"demonstration.md\"]\nDepth = 2","category":"page"},{"location":"#Validation-of-Baseline","page":"Home","title":"Validation of Baseline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Validation of our implementation of the key baseline in the paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"baseline.md\"]\nDepth = 2","category":"page"},{"location":"baseline/#Validation-of-Baseline","page":"Validation of Baseline","title":"Validation of Baseline","text":"","category":"section"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"To validate the implementation of our key baseline, generalized likelihood ratio testing (GLRT) as proposed by Chung et al. [CBMH2007]. In particular, we reproduce Fig. 4 of the paper, which are the results for k=3 wideband sources. We will try to follow the experimental setup in the paper as closely as possible.","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"[CBMH2007]: Chung, P. J., Bohme, J. F., Mecklenbrauker, C. F., & Hero, A. O. (2007). Detection of the number of signals using the Benjamini-Hochberg procedure. IEEE Transactions on Signal Processing, 55(6), 2497-2508.","category":"page"},{"location":"baseline/#System-Setup","page":"Validation of Baseline","title":"System Setup","text":"","category":"section"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"using Accessors\nusing FFTW\nusing FillArrays\nusing LinearAlgebra\nusing MKL\nusing NLopt\nusing Optim, LineSearches\nusing Peaks\nusing Random\nusing SpecialFunctions\nusing StatsBase\nusing StatsFuns\nusing Tullio\n\ninclude(\"../../scripts/baselines/common.jl\")\ninclude(\"../../scripts/baselines/directml.jl\")\ninclude(\"../../scripts/baselines/likeratiotest.jl\")\ninclude(\"../../scripts/common.jl\")\nnothing","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"Here is the system setup.","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"n_fft  = 64 # Number of requency bins (J in the original paper)\nn_snap = 10 # Number of snapshots (K in the original paper) \n\nfs      = 2000         # Sampling frequency [Hz]\nN       = n_fft*n_snap # Number of samples\nM       = 15           # Number of sensors\nf0      = fs/3         # Maximum frequency  [Hz]\nc       = 1500         # Propagation speed of the medium [m/s]\nλ       = c/f0         # Minimum wavelength \nspacing = λ/2          # Inter-sensor spacing [m]\nΔx      = range(0, M*spacing; length=M) # Relative sensor position\nnothing","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"Unfortunately, the original paper does not specify the sampling frequency and target frequency they used.  Therefore, we had to pick some arbitrary number for fs and f0.","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"The k = 3 targets and their bandwidths are set as follows:","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"ϕ   = [-30, 20, 24] / 180*π  # Direction-of-Arrivals\nΔf  = f0 - (17/32*f0)        # Signal bandwidth\nnothing","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"We now generate the source signals by band-limiting white Gaussian noise. ","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"using DSP\nusing Random123\n\nseed = (0x97dcb950eaebcfba, 0x741d36b68bef6415)\nrng  = Random123.Philox4x(UInt64, seed, 8)\nRandom123.set_counter!(rng, 1)\n\nϵ   = randn(rng, N, length(ϕ))\nbpf = DSP.Filters.digitalfilter(\n    DSP.Filters.Bandpass(17/32*f0, f0, fs=fs), \n    DSP.Filters.Butterworth(8)\n)\nx   = mapslices(xi -> DSP.Filters.filt(bpf, xi), ϵ; dims=1)\nnothing","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"GLRT uses the following key parameters:","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"k_max   = 4    # Maximum number of targets\nq       = 0.1  # False discovery rate\nnothing","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"The simulation range is set as follows:","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"snrs     = -8:2:6\nn_trials = 30\nnothing","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"Let's run the simulation.","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"filter   = WidebandDoA.WindowedSinc(N)\npcorrect = map(snrs) do snr\n    mean(1:n_trials) do _\n        σ2   = 10^(-snr/10)\n        like = WidebandIsoIsoLikelihood(N, 4*N, filter, Δx, c, fs)\n        y    = rand(rng, like, x, ϕ; sigma=sqrt(σ2*Δf/fs))\n\n        config        = ArrayConfig(c, Δx)\n        R, Y, f_range = snapshot_covariance(y, n_fft, fs, n_snap)\n\n        # The original paper only states that they use J = 10 frequency bins.\n        # We pick 10 bins that sufficiently cover the target frequency f0.\n        idx_sel = 13:22\n        R_sel   = R[:,:,idx_sel]\n        f_sel   = f_range[idx_sel]\n        Y_sel   = Y[:,:,idx_sel]\n\n        k, _ = likeratiotest(\n            rng, Y_sel, R_sel, q, k_max, n_snap, f_sel, config; visualize=false\n        )\n        k == length(ϕ)\n    end\nend\nnothing","category":"page"},{"location":"baseline/#Result","page":"Validation of Baseline","title":"Result","text":"","category":"section"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"using Plots\n\nPlots.plot(snrs, pcorrect, xlabel=\"SNR\", ylabel=\"Prob. of Correct Detection\", ylims=[0, 1])\nsavefig(\"baseline.svg\")\nnothing","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"(Image: )","category":"page"},{"location":"baseline/","page":"Validation of Baseline","title":"Validation of Baseline","text":"Compare this against Fig. 4 in the original paper[CBMH2007]. We can see the results are very close: the probability of correct detection converges to a 100% around -3 dB.","category":"page"},{"location":"demonstration/#demo","page":"Demonstration","title":"Demonstration","text":"","category":"section"},{"location":"demonstration/#System-Setup","page":"Demonstration","title":"System Setup","text":"","category":"section"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"We demonstrate the use of the package.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"First, let's setup the array geometry. We will consider a system with a uniform linear array (ULA) with M = 20 sensors and a spacing of 0.5 m, a sampling frequency of fs = 3000Hz, where the medium has a propagation speed of c = 1500 m/s:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"M  = 20\nΔx = range(0, M*0.5; length=M)\nc  = 1500.\nfs = 3000.\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"For the target sources, we will generate k = 4 targets, with varying bandwidths and varying SNRs:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"k       = 4\nϕ       = [ -60,  -15,  30,  45]/180*π # True direction-of-arrivals\nf_begin = [  10,  100, 500, 800]       # Source signal starting frequencies\nf_end   = [1000, 1500,1000, 900]       # Source signal ending frequencies\nsnr     = [  -6,   -4,   0,   4]       # Source signal SNRs in dB\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"For simulating the signals, let's use a utility function we used for the experiments. The length of the simulated signal will be N = 256. This corresponds to using S = 8 snapshots in the paper.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"using Random, Random123\n\nseed = (0x97dcb950eaebcfba, 0x741d36b68bef6415)\nrng  = Random123.Philox4x(UInt64, seed, 8)\nRandom123.set_counter!(rng, 1)\n\nN = 256\n\ninclude(\"../../scripts/common.jl\")\ny, x  = simulate_signal(\n    rng, N, N*8, ϕ, snr, f_begin, f_end, fs, 1.0, Δx, c; visualize=false\n)\ny","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"We can visualize the simulated signal through beamforming. Consider the Capon spectral estimator, more commonly known as minimum-variance distortionless response, or MVDR for short :","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"using Tullio\nusing Plots\n\ninclude(\"../../scripts/baselines/common.jl\")\ninclude(\"../../scripts/baselines/subbandbeamform.jl\")\n\nN_fft  = 32\nN_snap = N ÷ N_fft\n\nR, _, f_range = snapshot_covariance(y, N_fft, fs, N_snap) # Short-time Fourier transform\n\nconfig  = ArrayConfig(c, Δx)\nn_grid  = 2^10\nϕ_range = range(-π/2, π/2; length=n_grid)\nP       = subbandmvdr(R, ϕ_range, f_range, config)\nPlots.heatmap(ϕ_range, f_range, 10*log10.(P'), xlabel=\"DoA (ϕ)\", ylabel=\"Frequency\")\nPlots.vline!(ϕ, label=\"True DoAs\", linecolor=:red)\nsavefig(\"angle_frequency_spectrum_plot.svg\")\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"This yields the angle-frequency spectrum:  (Image: )","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"We can see that the signals were correctly simulated as we specified.","category":"page"},{"location":"demonstration/#Creating-the-Bayesian-Model","page":"Demonstration","title":"Creating the Bayesian Model","text":"","category":"section"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Now, let's construct the Bayesian model. We will use a non-informative inverse-gamma prior on the source SNRs (gamma in the paper), a truncated negative-binomial prior on the model order (k), a Jeffrey's scale prior on the signal power (sigma^2) as stated in the paper:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"alpha, beta  = 0, 0\nsource_prior = InverseGamma(0.01, 0.01)\norder_prior  = truncated(NegativeBinomial(1/2 + 0.1, 0.1/(0.1 + 1)), 0, M-1)\nmodel        = WidebandDoA.WidebandIsoIsoModel(\n    N, Δx, c, fs, source_prior, alpha, beta; order_prior\n)\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"The model can be conditioned on the data as follows:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"cond  = WidebandConditioned(model, y)\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"We are now ready to infer the posterior for this model.","category":"page"},{"location":"demonstration/#Inference-with-RJMCMC","page":"Demonstration","title":"Inference with RJMCMC","text":"","category":"section"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"For inference, we will use the ReversibleJump package, which is the inference counterpart of this package.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"We use independent jump proposals with the uniform-log-normal auxiliary proposal distributions (q(phi), q(gamma) in the paper) as done in the paper:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"using ReversibleJump\n\nprop = UniformNormalLocalProposal(0.0, 2.0)\njump = IndepJumpProposal(prop)\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"For the update move, we will use slice sampling[N2003] with the stepping-out procedure:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"mcmc = SliceSteppingOut([2.0, 2.0])\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"[N2003]: Neal, Radford M. \"Slice sampling.\" The annals of statistics 31.3 (2003): 705-767.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"The RJMCMC algorithm we use is the non-reversible jump algorithm by Gagnon and Doucet[GD2020].","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"rjmcmc = ReversibleJump.NonReversibleJumpMCMC(jump, mcmc; jump_rate=0.9)\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"[GD2020]: Gagnon, Philippe, and Arnaud Doucet. \"Nonreversible jump algorithms for Bayesian nested model selection.\" Journal of Computational and Graphical Statistics 30.2 (2020): 312-323.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Now let's simulate some Markov chains!","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"n_samples = 4_000\n\ninitial_params = WidebandDoA.WidebandIsoIsoParam{Float64}[]\ninitial_order  = 0\nsamples, stats = ReversibleJump.sample(\n    rng,\n    rjmcmc,\n    cond,\n    n_samples,\n    initial_order,\n    initial_params;\n    show_progress=false,\n)\nsamples","category":"page"},{"location":"demonstration/#Signal-Detection","page":"Demonstration","title":"Signal Detection","text":"","category":"section"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Detection can be performed by analyzing the posterior of the model order (k).","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Here is the trace of the model order:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Plots.plot([stat.order for stat in stats],  xlabel=\"RJMCMC Iteration\",  ylabel=\"Model order\")\nsavefig(\"model_order_trace.svg\")\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"(Image: )","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"And the histogram:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Plots.histogram([stat.order for stat in stats], xlabel=\"order\", normed=true)\nsavefig(\"model_order_hist.svg\")\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"(Image: )","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"From the posterior, we can obtain point estimates of the model order k. In the paper, we use the median.","category":"page"},{"location":"demonstration/#DoA-Estimation","page":"Demonstration","title":"DoA Estimation","text":"","category":"section"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Now, let's estimate the DoAs.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"For this, we will discard the first 10% of the samples and only use the remaining samples.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"burned = samples[n_samples ÷ 10:end]","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Bayesian model averaging (BMA) correponds to flattening all the local variables:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"flat = vcat(burned...)","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"On the other hand, Bayesian model selection corresponds to selecting the samples that have a specific model order.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Here is the marginal posterior of the DoAs:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Plots.histogram([θ.phi for θ in flat], normed=true, bins=256, xlims=[-π/2, π/2], xlabel=\"DoA (ϕ)\", label=\"Posterior\", ylabel=\"Density\")\nPlots.vline!(ϕ, label=\"True\", color=:red, linestyle=:dash)\nsavefig(\"doa_hist.svg\")\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"(Image: )","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Unfortunately, this does not yield the DoA posterior corresponding to each source. For this, we turn to the relabeling algorithm by Roodaki et al.[RBF2014]. This algorithm fits a Gaussian mixture model on the histogram above. It also generates labels for each local variable, so that we can label variable other than just the DoAs. For this though, we have to choose the number of mixture components.  Roodaki et al. recommend the 80% or 90% upper percentile of the posterior:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"k_mixture = quantile([stat.order for stat in stats], 0.9) |> Base.Fix1(round, Int)\nϕ_post    = [[target.phi for target in sample] for sample in burned]\nmixture, labels = WidebandDoA.relabel(\n    rng, ϕ_post, k_mixture; show_progress=false\n)\nmixture","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"[RBF2014]: Roodaki, Alireza, Julien Bect, and Gilles Fleury. \"Relabeling and summarizing posterior distributions in signal decomposition problems when the number of components is unknown.\" IEEE Transactions on Signal Processing (2014).","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Let's check that the Gaussian mixture approximation is accurate. This can be done by comparing the marginal density of the mixture against the histogram:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"using StatsPlots\n\nPlots.stephist([θ.phi for θ in flat], normed=true, bins=256, xlims=[-π/2, π/2], xlabel=\"DoA (ϕ)\", ylabel=\"Density\", label=\"Posterior\", fill=true)\nPlots.plot!(range(-π/2,π/2; length=1024), Base.Fix1(pdf, mixture), label=\"Mixture Approximation\", linewidth=2)\nsavefig(\"doa_relabel_density.svg\")\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"(Image: )","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"The DoA posterior of each source is then represented by each component of the mixture:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Plots.plot(mixture, xlims=[-π/2, π/2], label=\"Component\", fill=true)\nPlots.vline!(ϕ, label=\"True\", color=:red, linestyle=:dash)\nsavefig(\"doa_relabel_comp.svg\")\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"(Image: )","category":"page"},{"location":"demonstration/#Reconstruction","page":"Demonstration","title":"Reconstruction","text":"","category":"section"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Finally, we will demonstrate reconstruction. Unfortunately, the API for reconstruction is a little less ironed-out, but it is functional.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"For this, we have to use the labels generated by the relabeling procedure. Here, for each RJMCMC sample, we will sample from the conditional posterior conditional and then relabel the signal segments to their corresponding source. We also thin the samples by a factor n_thin = 100 to speed up things and reduce memory consumption.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"x_samples = [Vector{Float64}[] for j in 1:k_mixture]\nx_means   = [Vector{Float64}[] for j in 1:k_mixture]\n\nn_thin = n_samples ÷ 10\n\nsamples_thinned = burned[1:n_thin:end]\nlabels_thinned  = labels[1:n_thin:end]\n\nfor (sample, labs) in zip(samples_thinned, labels_thinned)\n    dist_x   = WidebandDoA.reconstruct(cond, sample)\n    x_sample = rand(rng, dist_x) # Conditional posterior sample\n    x_mean   = mean(dist_x)      # Conditional posterior mean\n\n    kj        = length(sample)\n    total_len = length(x_sample)\n    blocksize = total_len ÷ kj\n\n    # Labeling the conditional posterior mean and sample\n    for (idx, label) in enumerate(labs)\n        if label > k_mixture\n            # A label of k_mixture + 1 corresponds to clutter\n            continue\n        end\n\n        # The source signals are flattened so we have to slice the block corresponding\n        # to the source the label is pointing to.\n        blockrange = (idx-1)*blocksize+1:idx*blocksize\n        xj_sample  = x_sample[blockrange[1:N]]\n        xj_mean    = x_mean[  blockrange[1:N]]\n        push!(x_samples[label], xj_sample)\n        push!(x_means[label],   xj_mean)\n    end\nend\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Now that sampling and relabeling is done, we can visualize the posterior samples against with the minimum mean-squared error (MMSE) estimates (posterior mean). The variability of the posterior samples represent the posterior uncertainty:","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"x_mmse = mean.(x_samples)\n\nplts = map(1:k_mixture) do j\n    p = Plots.plot(x_mmse[j], linecolor=:blue, label=\"MMSE\", xlabel=\"Sample index\")\n    for x_sample in x_samples[j]\n        Plots.plot!(p, x_sample, linecolor=:blue, alpha=0.5, linewidth=0.2, label=nothing)\n    end\n    p\nend\nPlots.plot(plts..., layout = (4, 1))\nsavefig(\"recon_samples.svg\")\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"(Image: )","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Finally, let's compare the MMSE against the ground truth x.","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"Plots.plot( x_mmse, layout=(4,1), label=\"MMSE\", xlabel=\"Sample Index\")\nPlots.plot!(x,      layout=(4,1), label=\"True\", xlabel=\"Sample Index\")\nsavefig(\"recon_mmse_comparison.svg\")\nnothing","category":"page"},{"location":"demonstration/","page":"Demonstration","title":"Demonstration","text":"(Image: )","category":"page"}]
}
